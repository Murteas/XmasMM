<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Expert Mobile Layout Test - XmasMM</title>
  <link rel="icon" type="image/png" href="../assets/icon.png">
  <link rel="apple-touch-icon" href="../assets/icon.png">
  
  <!-- Phaser.js -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  
  <!-- Game Scripts -->
  <script src="../js/utils/TestConfig.js?v=1"></script>
  <script src="../js/utils/GameUtils.js?v=1"></script>
  <script src="../js/managers/GameStateManager.js"></script>
  <script src="../js/managers/ScoreManager.js"></script>
  <script src="../js/managers/UILayoutManager.js"></script>
  <script src="../js/managers/ActiveRowManager.js"></script>
  <script src="../js/managers/ElementPicker.js"></script>
  <script src="../js/managers/GameInputHandler.js"></script>
  <script src="../js/managers/HistoryManager.js"></script>
  <script src="../js/managers/HistoryRenderer.js"></script>
  <script src="../js/managers/HistoryScroller.js"></script>
  <script src="../js/scenes/MainMenu.js"></script>
  <script src="../js/scenes/DifficultySelection.js"></script>
  <script src="../js/scenes/GameScene.js"></script>
  <script src="../js/scenes/RoundOver.js"></script>
  
  <style>
    /* Safe area CSS variables */
    :root {
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);
    }
    
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: white;
      font-family: Arial, sans-serif;
      overflow: auto; /* Allow scrolling when device is scaled */
      min-height: 100vh;
    }
    
    #game-container {
      transition: all 0.3s ease;
      background: #000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    /* Override main CSS for device simulation */
    #game-container.device-simulation canvas {
      position: relative !important;
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      max-height: none !important;
      top: 0 !important;
      left: 0 !important;
    }
    
    .test-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.95);
      padding: env(safe-area-inset-top, 10px) 15px 15px 15px;
      border-radius: 0 0 12px 12px;
      z-index: 2000;
      font-size: 11px;
      backdrop-filter: blur(10px);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .test-overlay.visible {
      transform: translateY(0);
    }
    
    .test-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .device-button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      flex: 1;
      min-width: 80px;
    }
    
    .device-button:hover {
      background: #45a049;
    }
    
    .device-button.active {
      background: #FF9800;
    }
    
    .metrics {
      background: rgba(255,255,255,0.1);
      padding: 8px;
      border-radius: 6px;
      margin-top: 8px;
      font-size: 10px;
    }
    
    .fps-monitor {
      background: rgba(255,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
    }
    
    .fps-good { background: rgba(0,255,0,0.8); }
    .fps-warning { background: rgba(255,165,0,0.8); }
    .fps-critical { background: rgba(255,0,0,0.8); }
    
    .toggle-btn {
      position: fixed;
      top: env(safe-area-inset-top, 10px);
      right: 15px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      z-index: 2001;
      backdrop-filter: blur(5px);
    }
    
    .safe-area-indicator {
      position: fixed;
      border: 2px dashed rgba(255,255,0,0.5);
      pointer-events: none;
      z-index: 1999;
    }
    
    .safe-area-top {
      top: 0;
      left: 0;
      right: 0;
      height: env(safe-area-inset-top, 0px);
      border-bottom: 2px dashed rgba(255,255,0,0.8);
    }
    
    .safe-area-bottom {
      bottom: 0;
      left: 0;
      right: 0;
      height: env(safe-area-inset-bottom, 0px);
      border-top: 2px dashed rgba(255,255,0,0.8);
    }
  </style>
</head>
<body>
  <!-- Safe Area Indicators -->
  <div class="safe-area-indicator safe-area-top"></div>
  <div class="safe-area-indicator safe-area-bottom"></div>
  
  <!-- Toggle Button -->
  <button class="toggle-btn" onclick="toggleTestOverlay()">üì± Tests</button>
  
  <!-- Test Overlay -->
  <div class="test-overlay" id="testOverlay">
    <div class="test-row">
      <div class="fps-monitor" id="fpsMonitor">FPS: --</div>
      <button class="device-button" onclick="runLayoutValidation()">‚úì Validate Layout</button>
      <button class="device-button" onclick="runPerformanceTest()">‚ö° Performance</button>
    </div>
    
    <div class="test-row">
      <button class="device-button" onclick="setDeviceSize(375, 667)">iPhone SE</button>
      <button class="device-button active" onclick="setDeviceSize(414, 896)">iPhone XR</button>
      <button class="device-button" onclick="setDeviceSize(428, 926)">iPhone Pro Max</button>
    </div>
    
    <div class="test-row">
      <button class="device-button" onclick="resetToFullScreen()" style="background: #9C27B0;">üñ•Ô∏è Full Screen</button>
      <button class="device-button" onclick="testTouchTargets()">üëÜ Touch Targets</button>
      <button class="device-button" onclick="testSafeAreas()">üìê Safe Areas</button>
      <button class="device-button" onclick="testTextWrapping()">üìù Text Wrap</button>
    </div>
    
    <div class="metrics" id="deviceMetrics">
      Loading device metrics...
    </div>
    
    <div class="metrics" id="testResults">
      Ready for testing...
    </div>
  </div>

  <div id="game-container"></div>

  <script>
    // Expert Mobile Testing System
    let game;
    let fpsCounter = 0;
    let lastTime = performance.now();
    let testOverlayVisible = false;

    // Initialize game with mobile optimization
    // Check if we should start with a specific device simulation
    const defaultDevice = { width: 414, height: 896 }; // iPhone XR as default
    
    const config = {
      type: Phaser.AUTO,
      width: defaultDevice.width,
      height: defaultDevice.height,
      parent: 'game-container',
      backgroundColor: '#1a1a2e',
      scale: {
        mode: Phaser.Scale.NONE, // Use NONE to prevent auto-scaling issues
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: [MainMenu, DifficultySelection, GameScene, RoundOver],
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      }
    };

    // Performance monitoring
    function updateFPS() {
      const now = performance.now();
      const delta = now - lastTime;
      lastTime = now;
      
      if (delta > 0) {
        const fps = Math.round(1000 / delta);
        fpsCounter = fps;
        
        const fpsMonitor = document.getElementById('fpsMonitor');
        fpsMonitor.textContent = `FPS: ${fps}`;
        
        // Color coding
        fpsMonitor.className = 'fps-monitor';
        if (fps >= 55) fpsMonitor.classList.add('fps-good');
        else if (fps >= 45) fpsMonitor.classList.add('fps-warning');
        else fpsMonitor.classList.add('fps-critical');
      }
      
      requestAnimationFrame(updateFPS);
    }

    // Device simulation
    function setDeviceSize(width, height) {
      document.querySelectorAll('.device-button').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      console.log(`üîÑ Setting device size: ${width}√ó${height}`);
      
      // Simulate device viewport with proper scaling
      const container = document.getElementById('game-container');
      const body = document.body;
      
      // Reset any previous transformations
      container.style.transform = '';
      container.style.transformOrigin = '';
      container.style.width = '';
      container.style.height = '';
      container.style.margin = '';
      container.style.border = '';
      container.style.borderRadius = '';
      container.style.position = '';
      container.style.boxShadow = '';
      
      // Calculate scale to fit device in viewport if needed
      const maxWidth = window.innerWidth - 40; // Leave margin
      const maxHeight = window.innerHeight - 200; // Leave space for test overlay
      
      let scale = 1;
      if (width > maxWidth || height > maxHeight) {
        const scaleX = maxWidth / width;
        const scaleY = maxHeight / height;
        scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
        console.log(`üì± Scaling device to ${(scale * 100).toFixed(1)}% to fit viewport`);
      }
      
      // Apply device simulation styles
      container.style.width = width + 'px';
      container.style.height = height + 'px';
      container.style.margin = '100px auto 20px auto'; // Top margin for test overlay
      container.style.border = '2px solid #444';
      container.style.borderRadius = '12px'; // Make it look like a phone
      container.style.overflow = 'hidden';
      container.style.position = 'relative';
      
      // Add CSS class for device simulation
      container.classList.add('device-simulation');
      
      if (scale < 1) {
        container.style.transform = `scale(${scale})`;
        container.style.transformOrigin = 'center top';
      }
      
      // DON'T change viewport meta - this can cause conflicts
      // Instead, let Phaser handle the scaling internally
      
      // Resize game if it exists
      if (game) {
        console.log(`üéÆ Resizing Phaser game to ${width}√ó${height}`);
        
        // IMPORTANT: Override GameUtils viewport detection for device simulation
        if (typeof GameUtils !== 'undefined') {
          GameUtils._simulatedViewport = {
            width: width,
            height: height,
            devicePixelRatio: window.devicePixelRatio || 1,
            aspectRatio: width / height,
            isSmallDevice: width <= 375,
            isStandardDevice: width >= 414 && width <= 428,
            orientation: height > width ? 'portrait' : 'landscape'
          };
          console.log(`üéØ Set simulated viewport for GameUtils:`, GameUtils._simulatedViewport);
        }
        
        // First, update the game's canvas size
        game.scale.resize(width, height);
        
        // Force camera bounds update
        setTimeout(() => {
          if (game.scene && game.scene.manager) {
            const activeScenes = game.scene.manager.getScenes(true);
            activeScenes.forEach(scene => {
              if (scene.cameras && scene.cameras.main) {
                console.log(`üé• Updating camera for scene ${scene.scene.key}: ${width}√ó${height}`);
                scene.cameras.main.setSize(width, height);
                scene.cameras.main.setBounds(0, 0, width, height);
              }
            });
          }
        }, 25);
        
        // Force canvas to match container size exactly
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            // Override CSS !important rules by setting them with !important
            canvas.style.setProperty('width', width + 'px', 'important');
            canvas.style.setProperty('height', height + 'px', 'important');
            canvas.style.setProperty('position', 'relative', 'important');
            canvas.style.setProperty('top', '0', 'important');
            canvas.style.setProperty('left', '0', 'important');
            canvas.style.setProperty('max-width', width + 'px', 'important');
            canvas.style.setProperty('max-height', height + 'px', 'important');
            
            console.log(`üéØ Canvas resized to ${width}√ó${height}`);
            console.log(`üéØ Canvas computed style: ${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}`);
          } else {
            console.warn('‚ùå Canvas not found for resizing');
          }
        }, 50);
        
        // Trigger a layout update in the current scene
        if (game.scene.isActive('MainMenu')) {
          const scene = game.scene.getScene('MainMenu');
          if (scene && scene.updateLayout) {
            scene.updateLayout();
          }
        }
        
        // Force a scene refresh to ensure proper positioning
        safeSceneRefresh(game, 200); // Longer delay for camera updates
      }
      
      updateDeviceMetrics();
      
      // Update test results with device info
      setTimeout(() => {
        const canvas = document.querySelector('canvas');
        const canvasInfo = canvas ? 
          `${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}` : 
          'Not found';
        
        document.getElementById('testResults').innerHTML = `
          <strong>Device Simulation Active:</strong><br>
          üì± Size: ${width}√ó${height}px<br>
          üìê Scale: ${(scale * 100).toFixed(1)}%<br>
          üéØ Container: ${container.style.width} √ó ${container.style.height}<br>
          üñ•Ô∏è Viewport: ${window.innerWidth}√ó${window.innerHeight}<br>
          üéÆ Canvas: ${canvasInfo}<br>
          üîç Canvas Element: ${canvas ? 'Found' : 'Missing'}
        `;
      }, 100);
    }

    // Helper function to safely refresh Phaser scenes
    function safeSceneRefresh(gameInstance, delay = 100) {
      if (!gameInstance) {
        console.log('üîÑ No game instance for scene refresh');
        return;
      }
      
      setTimeout(() => {
        try {
          console.log('üîÑ Scene refresh starting - GameUtils viewport check...');
          const currentViewport = GameUtils.getMobileViewport();
          console.log('üì± Current GameUtils viewport:', currentViewport);
          
          if (gameInstance && 
              gameInstance.scene && 
              gameInstance.scene.manager && 
              gameInstance.scene.manager.scenes && 
              gameInstance.scene.manager.scenes.length > 0) {
            
            console.log(`üîÑ Found ${gameInstance.scene.manager.scenes.length} scenes`);
            
            // Get the currently active scene
            const activeScenes = gameInstance.scene.manager.getScenes(true);
            console.log(`üîÑ Active scenes:`, activeScenes.map(s => s.scene.key));
            
            if (activeScenes.length > 0) {
              const activeScene = activeScenes[0];
              console.log(`üîÑ Refreshing active scene: ${activeScene.scene.key}`);
              
              // Log camera info before restart
              if (activeScene.cameras && activeScene.cameras.main) {
                console.log('üì∏ Current camera size:', {
                  width: activeScene.cameras.main.width,
                  height: activeScene.cameras.main.height
                });
              }
              
              // Force scene to restart with new viewport
              const sceneKey = activeScene.scene.key;
              const sceneData = activeScene.scene.settings.data || {};
              
              console.log(`üéØ About to restart scene ${sceneKey} with viewport:`, currentViewport);
              
              // Restart the scene completely
              gameInstance.scene.restart(sceneKey, sceneData);
              console.log(`‚úÖ Scene ${sceneKey} restart command sent`);
              
              // Check after restart
              setTimeout(() => {
                const newActiveScenes = gameInstance.scene.manager.getScenes(true);
                console.log(`üìã Post-restart active scenes:`, newActiveScenes.map(s => s.scene.key));
                
                if (newActiveScenes.length > 0 && newActiveScenes[0].cameras && newActiveScenes[0].cameras.main) {
                  console.log('üì∏ New camera size:', {
                    width: newActiveScenes[0].cameras.main.width,
                    height: newActiveScenes[0].cameras.main.height
                  });
                }
              }, 100);
            }
          } else {
            console.log('üîÑ Game or scene manager not ready for refresh');
          }
        } catch (error) {
          console.warn('Scene refresh error:', error.message);
        }
      }, delay);
    }

    // Update device metrics display
    function updateDeviceMetrics() {
      // Enhanced safety check for GameUtils availability
      console.log('Checking GameUtils...', typeof GameUtils);
      if (typeof GameUtils !== 'undefined') {
        console.log('GameUtils methods:', Object.getOwnPropertyNames(GameUtils));
      }
      
      if (typeof GameUtils === 'undefined' || !GameUtils.getMobileViewport) {
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Loading GameUtils...</strong><br>
          Waiting for game scripts to initialize...<br>
          <small>GameUtils type: ${typeof GameUtils}</small>
        `;
        return;
      }
      
      try {
        const viewport = GameUtils.getMobileViewport();
        const layout = GameUtils.getResponsiveLayout(viewport.width, viewport.height);
        const safeArea = GameUtils.getSafeAreaInsets();
        
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Viewport:</strong> ${viewport.width}√ó${viewport.height} (${viewport.aspectRatio.toFixed(2)}:1)<br>
          <strong>Font Scale:</strong> ${layout.fontScale}x | <strong>Device Type:</strong> ${viewport.isSmallDevice ? 'Small' : 'Standard'}<br>
          <strong>Safe Area:</strong> T:${safeArea.top} R:${safeArea.right} B:${safeArea.bottom} L:${safeArea.left}<br>
          <strong>Touch Targets:</strong> Min ${layout.minTouchTarget}px | <strong>Button Scale:</strong> ${layout.buttonScale}x
        `;
      } catch (error) {
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Error:</strong> ${error.message}<br>
          Check console for details...<br>
          <small>GameUtils: ${typeof GameUtils}</small>
        `;
        console.error('GameUtils error:', error);
      }
    }

    // Test functions
    function toggleTestOverlay() {
      testOverlayVisible = !testOverlayVisible;
      const overlay = document.getElementById('testOverlay');
      overlay.classList.toggle('visible', testOverlayVisible);
    }

    function runLayoutValidation() {
      console.log('Running layout validation...', typeof GameUtils);
      
      if (typeof GameUtils === 'undefined' || !GameUtils.getMobileViewport) {
        document.getElementById('testResults').innerHTML = `
          GameUtils not loaded yet. Please wait...<br>
          <small>Type: ${typeof GameUtils}</small><br>
          <button onclick="updateDeviceMetrics(); runLayoutValidation();" style="margin-top:5px; padding:2px 6px; font-size:9px;">üîÑ Retry</button>
        `;
        return;
      }
      
      try {
        const results = [];
        const viewport = GameUtils.getMobileViewport();
        const layout = GameUtils.getResponsiveLayout(viewport.width, viewport.height);
        
        // Check button positioning
        if (layout.primaryButtonY > viewport.height - 100) {
          results.push('‚ùå Primary button too low');
        } else {
          results.push('‚úÖ Primary button positioned correctly');
        }
      
      // Check safe areas
      const safeArea = GameUtils.getSafeAreaInsets();
      if (layout.headerY > safeArea.top + 50) {
        results.push('‚úÖ Header respects safe area');
      } else {
        results.push('‚ö†Ô∏è Header may conflict with safe area');
      }
      
      // Check font scaling
      if (layout.fontScale >= 0.9 && layout.fontScale <= 1.2) {
        results.push('‚úÖ Font scaling within range');
      } else {
        results.push('‚ö†Ô∏è Font scaling may be extreme');
      }
      
      document.getElementById('testResults').innerHTML = results.join('<br>');
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Layout Validation Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Layout validation error:', error);
      }
    }

    function runPerformanceTest() {
      let frameCount = 0;
      let totalTime = 0;
      const startTime = performance.now();
      
      function measureFrames() {
        frameCount++;
        totalTime = performance.now() - startTime;
        
        if (totalTime >= 3000) { // 3 second test
          const avgFPS = Math.round((frameCount / totalTime) * 1000);
          const result = avgFPS >= 55 ? '‚úÖ' : avgFPS >= 45 ? '‚ö†Ô∏è' : '‚ùå';
          
          document.getElementById('testResults').innerHTML = `
            ${result} <strong>Performance Test Complete</strong><br>
            Average FPS: ${avgFPS}<br>
            Frames: ${frameCount} in ${Math.round(totalTime)}ms<br>
            Status: ${avgFPS >= 55 ? 'Excellent' : avgFPS >= 45 ? 'Good' : 'Needs Optimization'}
          `;
        } else {
          requestAnimationFrame(measureFrames);
        }
      }
      
      document.getElementById('testResults').innerHTML = 'Running 3-second performance test...';
      measureFrames();
    }

    function testTouchTargets() {
      // This would need integration with actual game scenes
      document.getElementById('testResults').innerHTML = `
        <strong>Touch Target Guidelines:</strong><br>
        ‚úÖ Minimum size: 44px √ó 44px<br>
        ‚úÖ Spacing: 12px between targets<br>
        üì± Test by tapping buttons in-game<br>
        üí° Check accessibility compliance
      `;
    }

    function testSafeAreas() {
      if (typeof GameUtils === 'undefined' || !GameUtils.getSafeAreaInsets) {
        document.getElementById('testResults').innerHTML = 'GameUtils not loaded yet. Please wait...';
        return;
      }
      
      try {
        const safeArea = GameUtils.getSafeAreaInsets();
        const hasNotch = safeArea.top > 20 || safeArea.bottom > 20;
        
        document.getElementById('testResults').innerHTML = `
          <strong>Safe Area Detection:</strong><br>
          ${hasNotch ? 'üì±' : 'üì±'} Device: ${hasNotch ? 'Has notch/home indicator' : 'Standard bezels'}<br>
          üìê Insets: ${safeArea.top}/${safeArea.right}/${safeArea.bottom}/${safeArea.left}<br>
          ${safeArea.top > 0 ? '‚úÖ' : '‚ùì'} CSS env() support: ${safeArea.top > 0 ? 'Working' : 'Check implementation'}
        `;
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Safe Area Test Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Safe area test error:', error);
      }
    }

    function testTextWrapping() {
      document.getElementById('testResults').innerHTML = `
        <strong>Text Wrapping Test:</strong><br>
        üìù Navigate to game over screen to test score explanation wrapping<br>
        üì± Check that long text fits within screen bounds<br>
        ‚úÖ Should use multiple lines instead of horizontal overflow<br>
        üí° Font should scale appropriately for device size
      `;
    }

    // Initialize
    window.addEventListener('load', () => {
      console.log('Window loaded, checking scripts...');
      
      // Hide TEST MODE overlay that blocks the Tests button
      setTimeout(() => {
        // Try multiple methods to find and hide the TEST MODE overlay
        const overlays = document.querySelectorAll('div');
        overlays.forEach(overlay => {
          const style = window.getComputedStyle(overlay);
          const text = overlay.textContent || overlay.innerText;
          
          if ((text.includes('TEST MODE') || text.includes('Screen:') || text.includes('DPR:')) && 
              (style.position === 'fixed' || style.position === 'absolute') &&
              (overlay.style.zIndex > 1000 || style.zIndex > 1000)) {
            overlay.style.display = 'none';
            console.log('üéØ Hidden TEST MODE overlay:', text.substring(0, 50));
          }
        });
        
        // Also try to hide by common test overlay patterns
        const testOverlays = document.querySelectorAll('[style*="position: fixed"], [style*="z-index"]');
        testOverlays.forEach(overlay => {
          const text = overlay.textContent || '';
          if (text.includes('TEST') || text.includes('Screen:') || text.includes('DPR:')) {
            overlay.style.display = 'none';
            console.log('üéØ Hidden test overlay via pattern matching');
          }
        });
      }, 200);
      
      // Keep checking for test overlays that might appear later
      setInterval(() => {
        const overlays = document.querySelectorAll('div[style*="position: fixed"], div[style*="position: absolute"]');
        overlays.forEach(overlay => {
          const text = overlay.textContent || '';
          if (text.includes('TEST MODE') || text.includes('Screen:') || text.includes('DPR:')) {
            if (overlay.style.display !== 'none') {
              overlay.style.display = 'none';
              console.log('üîÑ Continuously hidden test overlay');
            }
          }
        });
      }, 1000);
      
      // Debug script loading
      console.log('Available classes:');
      console.log('- Phaser:', typeof Phaser);
      console.log('- TestConfig:', typeof TestConfig);
      console.log('- GameUtils:', typeof GameUtils);
      console.log('- GameStateManager:', typeof GameStateManager);
      console.log('- MainMenu:', typeof MainMenu);
      
      // Debug GameUtils methods specifically
      if (typeof GameUtils !== 'undefined') {
        console.log('GameUtils methods:', Object.getOwnPropertyNames(GameUtils));
        console.log('GameUtils prototype methods:', Object.getOwnPropertyNames(GameUtils.prototype));
        console.log('All GameUtils properties:', Object.getOwnPropertyDescriptors(GameUtils));
        console.log('Checking mobile methods:');
        console.log('- getMobileViewport:', typeof GameUtils.getMobileViewport);
        console.log('- getResponsiveLayout:', typeof GameUtils.getResponsiveLayout);
        console.log('- getSafeAreaInsets:', typeof GameUtils.getSafeAreaInsets);
        
        // Test calling the method
        try {
          const testViewport = GameUtils.getMobileViewport();
          console.log('‚úÖ getMobileViewport works:', testViewport);
        } catch (error) {
          console.error('‚ùå getMobileViewport failed:', error);
        }
      }
      
      // Check if GameUtils.js actually loaded
      if (typeof GameUtils === 'undefined') {
        console.error('‚ùå GameUtils is undefined - script failed to load');
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>‚ùå GameUtils Script Failed</strong><br>
          Check Network tab for 404 errors<br>
          <small>Path: ../js/utils/GameUtils.js</small>
        `;
        document.getElementById('testResults').innerHTML = `
          <strong>Script Loading Debug:</strong><br>
          Phaser: ${typeof Phaser}<br>
          TestConfig: ${typeof TestConfig}<br>
          GameUtils: ${typeof GameUtils}<br>
          Check browser Network tab for failed requests
        `;
        return;
      }
      
      // Wait longer for all scripts to initialize
      setTimeout(() => {
        try {
          console.log('Initializing game...');
          
          // Set up default device simulation BEFORE game initialization
          if (typeof GameUtils !== 'undefined') {
            GameUtils._simulatedViewport = {
              width: defaultDevice.width,
              height: defaultDevice.height,
              devicePixelRatio: window.devicePixelRatio || 1,
              aspectRatio: defaultDevice.width / defaultDevice.height,
              isSmallDevice: defaultDevice.width <= 375,
              isStandardDevice: defaultDevice.width >= 414 && defaultDevice.width <= 428,
              orientation: defaultDevice.height > defaultDevice.width ? 'portrait' : 'landscape'
            };
            console.log(`üéØ Pre-initialized simulated viewport:`, GameUtils._simulatedViewport);
          }
          
          game = new Phaser.Game(config);
          
          // Set up device simulation UI after game loads
          setTimeout(() => {
            setDeviceSize(defaultDevice.width, defaultDevice.height);
          }, 100);
          
          updateFPS();
          updateDeviceMetrics();
          
          // Auto-hide overlay after 5 seconds
          setTimeout(() => {
            if (testOverlayVisible) toggleTestOverlay();
          }, 5000);
        } catch (error) {
          console.error('Game initialization error:', error);
          document.getElementById('testResults').innerHTML = `
            <strong>Initialization Error:</strong> ${error.message}<br>
            Check console for details...
          `;
        }
      }, 500);
    });

    // Handle viewport changes
    window.addEventListener('resize', () => {
      console.log('üîÑ Window resized, updating metrics');
      updateDeviceMetrics();
      
      // If in full screen mode, resize game to match
      const container = document.getElementById('game-container');
      if (container.style.width === '100vw' || !container.style.width) {
        if (game) {
          const width = window.innerWidth;
          const height = window.innerHeight;
          console.log(`üéÆ Auto-resizing game to: ${width}√ó${height}`);
          game.scale.resize(width, height);
        }
      }
    });

    // Prevent zoom on mobile
    document.addEventListener('touchstart', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // Reset to full screen mode
    function resetToFullScreen() {
      document.querySelectorAll('.device-button').forEach(btn => btn.classList.remove('active'));
      
      console.log('üñ•Ô∏è Resetting to full screen mode');
      
      const container = document.getElementById('game-container');
      
      // Reset all simulation styles completely
      container.style.width = '100vw';
      container.style.height = '100vh';
      container.style.margin = '0';
      container.style.border = 'none';
      container.style.borderRadius = '0';
      container.style.transform = '';
      container.style.transformOrigin = '';
      container.style.overflow = 'hidden';
      container.style.position = 'static';
      container.style.boxShadow = 'none';
      
      // Remove CSS class for device simulation
      container.classList.remove('device-simulation');
      
      // DON'T reset viewport meta - leave it as originally set
      
      // Reset body overflow
      document.body.style.overflow = 'hidden';
      
      // Resize game back to full screen
      if (game) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        console.log(`üéÆ Resizing game back to full screen: ${width}√ó${height}`);
        
        // Clear simulated viewport
        if (typeof GameUtils !== 'undefined') {
          GameUtils._simulatedViewport = null;
          console.log(`üéØ Cleared simulated viewport for GameUtils`);
        }
        
        game.scale.resize(width, height);
        
        // Reset canvas styles to original
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            // Restore original CSS rules with !important
            canvas.style.setProperty('width', '100vw', 'important');
            canvas.style.setProperty('height', '100vh', 'important');
            canvas.style.setProperty('position', 'fixed', 'important');
            canvas.style.setProperty('top', '0', 'important');
            canvas.style.setProperty('left', '0', 'important');
            canvas.style.removeProperty('max-width');
            canvas.style.removeProperty('max-height');
            
            console.log(`üéØ Canvas reset to full screen: ${width}√ó${height}`);
            console.log(`üéØ Canvas computed style: ${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}`);
          }
        }, 50);
        
        // Trigger scene refresh
        safeSceneRefresh(game, 150);
      }
      
      updateDeviceMetrics();
      
      document.getElementById('testResults').innerHTML = `
        <strong>Full Screen Mode:</strong><br>
        üñ•Ô∏è Device simulation disabled<br>
        üì± Using actual device viewport<br>
        üéØ Testing native mobile experience
      `;
    }
  </script>
</body>
</html>
