<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Expert Mobile Layout Test - XmasMM</title>
  <link rel="icon" type="image/png" href="../assets/icon.png">
  <link rel="apple-touch-icon" href="../assets/icon.png">
  
  <!-- Phaser.js -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  
  <!-- Game Scripts -->
  <script src="../js/utils/TestConfig.js?v=1"></script>
  <script src="../js/utils/GameUtils.js?v=1"></script>
  <script src="../js/managers/GameStateManager.js"></script>
  <script src="../js/managers/ScoreManager.js"></script>
  <script src="../js/managers/UILayoutManager.js"></script>
  <script src="../js/managers/ActiveRowManager.js"></script>
  <script src="../js/managers/ElementPicker.js"></script>
  <script src="../js/managers/GameInputHandler.js"></script>
  <script src="../js/managers/HistoryManager.js"></script>
  <script src="../js/managers/HistoryRenderer.js"></script>
  <script src="../js/managers/HistoryScroller.js"></script>
  <script src="../js/scenes/MainMenu.js"></script>
  <script src="../js/scenes/DifficultySelection.js"></script>
  <script src="../js/scenes/GameScene.js"></script>
  <script src="../js/scenes/RoundOver.js"></script>
  
  <style>
    /* Safe area CSS variables */
    :root {
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);
    }
    
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: white;
      font-family: Arial, sans-serif;
      overflow: auto; /* Allow scrolling when device is scaled */
      min-height: 100vh;
    }
    
    #game-container {
      transition: all 0.3s ease;
      background: #000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    /* Override main CSS for device simulation */
    #game-container.device-simulation canvas {
      position: relative !important;
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      max-height: none !important;
      top: 0 !important;
      left: 0 !important;
    }
    
    .test-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.95);
      padding: env(safe-area-inset-top, 10px) 15px 15px 15px;
      border-radius: 0 0 12px 12px;
      z-index: 2000;
      font-size: 11px;
      backdrop-filter: blur(10px);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .test-overlay.visible {
      transform: translateY(0);
    }
    
    .test-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .device-button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      flex: 1;
      min-width: 80px;
    }
    
    .device-button:hover {
      background: #45a049;
    }
    
    .device-button.active {
      background: #FF9800;
    }
    
    .metrics {
      background: rgba(255,255,255,0.1);
      padding: 8px;
      border-radius: 6px;
      margin-top: 8px;
      font-size: 10px;
    }
    
    .fps-monitor {
      background: rgba(255,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
    }
    
    .fps-good { background: rgba(0,255,0,0.8); }
    .fps-warning { background: rgba(255,165,0,0.8); }
    .fps-critical { background: rgba(255,0,0,0.8); }
    
    .toggle-btn {
      position: fixed;
      top: env(safe-area-inset-top, 10px);
      right: 15px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      z-index: 2001;
      backdrop-filter: blur(5px);
    }
    
    .safe-area-indicator {
      position: fixed;
      border: 2px dashed rgba(255,255,0,0.5);
      pointer-events: none;
      z-index: 1999;
    }
    
    .safe-area-top {
      top: 0;
      left: 0;
      right: 0;
      height: env(safe-area-inset-top, 0px);
      border-bottom: 2px dashed rgba(255,255,0,0.8);
    }
    
    .safe-area-bottom {
      bottom: 0;
      left: 0;
      right: 0;
      height: env(safe-area-inset-bottom, 0px);
      border-top: 2px dashed rgba(255,255,0,0.8);
    }
  </style>
</head>
<body>
  <!-- Safe Area Indicators -->
  <div class="safe-area-indicator safe-area-top"></div>
  <div class="safe-area-indicator safe-area-bottom"></div>
  
  <!-- Toggle Button -->
  <button class="toggle-btn" onclick="toggleTestOverlay()">üì± Tests</button>
  
  <!-- Test Overlay -->
  <div class="test-overlay" id="testOverlay">
    <div class="test-row">
      <div class="fps-monitor" id="fpsMonitor">FPS: --</div>
      <button class="device-button" onclick="runLayoutValidation()">‚úì Validate Layout</button>
      <button class="device-button" onclick="runPerformanceTest()">‚ö° Performance</button>
    </div>
    
    <div class="test-row">
      <button class="device-button" onclick="setDeviceSize(375, 667, this)">iPhone SE</button>
      <button class="device-button active" onclick="setDeviceSize(414, 896, this)">iPhone XR</button>
      <button class="device-button" onclick="setDeviceSize(428, 926, this)">iPhone Pro Max</button>
    </div>
    
    <div class="test-row">
      <button class="device-button" onclick="debugGameState()" style="background: #95a5a6;">ÔøΩ Debug Info</button>
      <button class="device-button" onclick="runPerformanceTest()">‚ö° Performance</button>
      <button class="device-button" onclick="toggleTestOverlay()">ÔøΩ Hide Panel</button>
    </div>
    
    <div class="test-row">
      <button class="device-button" onclick="testMOBILE006()" style="background: #e74c3c;">üîß MOBILE-006 Fix</button>
      <button class="device-button" onclick="simulateGameplay()" style="background: #e67e22;">üéÆ Populate 9 Guesses</button>
      <button class="device-button" onclick="quickGameTest()" style="background: #27ae60;">üéØ Quick Game Test</button>
      <button class="device-button" onclick="testMobileScroll()" style="background: #8e44ad;">üì± Test Scroll</button>
    </div>
    
    <div class="metrics" id="deviceMetrics">
      Loading device metrics...
    </div>
    
    <div class="metrics" id="testResults">
      Ready for testing...
    </div>
  </div>

  <div id="game-container"></div>

  <script>
    // Expert Mobile Testing System
    let game;
    let fpsCounter = 0;
    let lastTime = performance.now();
    let testOverlayVisible = false;

    // Initialize game with mobile optimization
    // Check if we should start with a specific device simulation
    const defaultDevice = { width: 414, height: 896 }; // iPhone XR as default
    
    const config = {
      type: Phaser.AUTO,
      width: defaultDevice.width,
      height: defaultDevice.height,
      parent: 'game-container',
      backgroundColor: '#1a1a2e',
      scale: {
        mode: Phaser.Scale.NONE, // Use NONE to prevent auto-scaling issues
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: [MainMenu, DifficultySelection, GameScene, RoundOver],
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      }
    };

    // Performance monitoring
    function updateFPS() {
      const now = performance.now();
      const delta = now - lastTime;
      lastTime = now;
      
      if (delta > 0) {
        const fps = Math.round(1000 / delta);
        fpsCounter = fps;
        
        const fpsMonitor = document.getElementById('fpsMonitor');
        fpsMonitor.textContent = `FPS: ${fps}`;
        
        // Color coding
        fpsMonitor.className = 'fps-monitor';
        if (fps >= 55) fpsMonitor.classList.add('fps-good');
        else if (fps >= 45) fpsMonitor.classList.add('fps-warning');
        else fpsMonitor.classList.add('fps-critical');
      }
      
      requestAnimationFrame(updateFPS);
    }

    // Device simulation
    function setDeviceSize(width, height, clickedButton = null) {
      document.querySelectorAll('.device-button').forEach(btn => btn.classList.remove('active'));
      
      // Handle both manual clicks and programmatic calls
      if (clickedButton) {
        clickedButton.classList.add('active');
      } else if (typeof event !== 'undefined' && event && event.target) {
        event.target.classList.add('active');
      } else {
        // For programmatic calls, find the button that matches this size
        const buttons = document.querySelectorAll('.device-button');
        buttons.forEach(btn => {
          if (btn.onclick && btn.onclick.toString().includes(`${width}, ${height}`)) {
            btn.classList.add('active');
          }
        });
      }
      
      console.log(`üîÑ Setting device size: ${width}√ó${height}`);
      
      // Simulate device viewport with proper scaling
      const container = document.getElementById('game-container');
      const body = document.body;
      
      // Reset any previous transformations
      container.style.transform = '';
      container.style.transformOrigin = '';
      container.style.width = '';
      container.style.height = '';
      container.style.margin = '';
      container.style.border = '';
      container.style.borderRadius = '';
      container.style.position = '';
      container.style.boxShadow = '';
      
      // Calculate scale to fit device in viewport if needed
      const maxWidth = window.innerWidth - 40; // Leave margin
      const maxHeight = window.innerHeight - 200; // Leave space for test overlay
      
      let scale = 1;
      if (width > maxWidth || height > maxHeight) {
        const scaleX = maxWidth / width;
        const scaleY = maxHeight / height;
        scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
        console.log(`üì± Scaling device to ${(scale * 100).toFixed(1)}% to fit viewport`);
      }
      
      // Apply device simulation styles
      container.style.width = width + 'px';
      container.style.height = height + 'px';
      container.style.margin = '100px auto 20px auto'; // Top margin for test overlay
      container.style.border = '2px solid #444';
      container.style.borderRadius = '12px'; // Make it look like a phone
      container.style.overflow = 'hidden';
      container.style.position = 'relative';
      
      // Add CSS class for device simulation
      container.classList.add('device-simulation');
      
      if (scale < 1) {
        container.style.transform = `scale(${scale})`;
        container.style.transformOrigin = 'center top';
      }
      
      // DON'T change viewport meta - this can cause conflicts
      // Instead, let Phaser handle the scaling internally
      
      // Resize game if it exists
      if (game) {
        console.log(`üéÆ Resizing Phaser game to ${width}√ó${height}`);
        
        // IMPORTANT: Override GameUtils viewport detection for device simulation
        if (typeof GameUtils !== 'undefined') {
          GameUtils._simulatedViewport = {
            width: width,
            height: height,
            devicePixelRatio: window.devicePixelRatio || 1,
            aspectRatio: width / height,
            isSmallDevice: width <= 375,
            isStandardDevice: width >= 414 && width <= 428,
            orientation: height > width ? 'portrait' : 'landscape'
          };
          console.log(`üéØ Set simulated viewport for GameUtils:`, GameUtils._simulatedViewport);
        }
        
        // First, update the game's canvas size
        game.scale.resize(width, height);
        
        // Force camera bounds update
        setTimeout(() => {
          if (game.scene && game.scene.scenes) {
            const activeScenes = game.scene.scenes.filter(s => s.scene.isActive());
            activeScenes.forEach(scene => {
              if (scene.cameras && scene.cameras.main) {
                console.log(`üé• Updating camera for scene ${scene.scene.key}: ${width}√ó${height}`);
                scene.cameras.main.setSize(width, height);
                scene.cameras.main.setBounds(0, 0, width, height);
              }
            });
          }
        }, 25);
        
        // Force canvas to match container size exactly
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            // Override CSS !important rules by setting them with !important
            canvas.style.setProperty('width', width + 'px', 'important');
            canvas.style.setProperty('height', height + 'px', 'important');
            canvas.style.setProperty('position', 'relative', 'important');
            canvas.style.setProperty('top', '0', 'important');
            canvas.style.setProperty('left', '0', 'important');
            canvas.style.setProperty('max-width', width + 'px', 'important');
            canvas.style.setProperty('max-height', height + 'px', 'important');
            
            console.log(`üéØ Canvas resized to ${width}√ó${height}`);
            console.log(`üéØ Canvas computed style: ${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}`);
          } else {
            console.warn('‚ùå Canvas not found for resizing');
          }
        }, 50);
        
        // Trigger a layout update in the current scene
        if (game.scene.isActive('MainMenu')) {
          const scene = game.scene.getScene('MainMenu');
          if (scene && scene.updateLayout) {
            scene.updateLayout();
          }
        } else if (game.scene.isActive('Game')) {
          const scene = game.scene.getScene('Game');
          if (scene && scene.updateLayout) {
            scene.updateLayout();
          }
        }
        
        // Force a scene refresh to ensure proper positioning
        safeSceneRefresh(game, 200); // Longer delay for camera updates
      }
      
      updateDeviceMetrics();
      
      // Update test results with device info
      setTimeout(() => {
        const canvas = document.querySelector('canvas');
        const canvasInfo = canvas ? 
          `${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}` : 
          'Not found';
        
        document.getElementById('testResults').innerHTML = `
          <strong>Device Simulation Active:</strong><br>
          üì± Size: ${width}√ó${height}px<br>
          üìê Scale: ${(scale * 100).toFixed(1)}%<br>
          üéØ Container: ${container.style.width} √ó ${container.style.height}<br>
          üñ•Ô∏è Viewport: ${window.innerWidth}√ó${window.innerHeight}<br>
          üéÆ Canvas: ${canvasInfo}<br>
          üîç Canvas Element: ${canvas ? 'Found' : 'Missing'}
        `;
      }, 100);
    }

    // Helper function to safely refresh Phaser scenes
    function safeSceneRefresh(gameInstance, delay = 100) {
      if (!gameInstance) {
        console.log('üîÑ No game instance for scene refresh');
        return;
      }
      
      setTimeout(() => {
        try {
          console.log('üîÑ Scene refresh starting - GameUtils viewport check...');
          const currentViewport = GameUtils.getMobileViewport();
          console.log('üì± Current GameUtils viewport:', currentViewport);
          
          if (gameInstance && 
              gameInstance.scene && 
              gameInstance.scene.scenes && 
              gameInstance.scene.scenes.length > 0) {
            
            console.log(`üîÑ Found ${gameInstance.scene.scenes.length} scenes`);
            
            // Get the currently active scene using correct Phaser API
            const activeScenes = gameInstance.scene.scenes.filter(s => s.scene.isActive());
            console.log(`üîÑ Active scenes:`, activeScenes.map(s => s.scene.key));
            
            if (activeScenes.length > 0) {
              const activeScene = activeScenes[0];
              console.log(`üîÑ Refreshing active scene: ${activeScene.scene.key}`);
              
              // Log camera info before restart
              if (activeScene.cameras && activeScene.cameras.main) {
                console.log('üì∏ Current camera size:', {
                  width: activeScene.cameras.main.width,
                  height: activeScene.cameras.main.height
                });
              }
              
              // Force scene to restart with new viewport - use correct Phaser API
              const sceneKey = activeScene.scene.key;
              const sceneData = activeScene.scene.settings.data || {};
              
              console.log(`üéØ About to restart scene ${sceneKey} with viewport:`, currentViewport);
              
              // Use the correct Phaser 3 restart method
              activeScene.scene.restart(sceneData);
              console.log(`‚úÖ Scene ${sceneKey} restart command sent`);
              
              // Check after restart
              setTimeout(() => {
                const newActiveScenes = gameInstance.scene.scenes.filter(s => s.scene.isActive());
                console.log(`üìã Post-restart active scenes:`, newActiveScenes.map(s => s.scene.key));
                
                if (newActiveScenes.length > 0 && newActiveScenes[0].cameras && newActiveScenes[0].cameras.main) {
                  console.log('üì∏ New camera size:', {
                    width: newActiveScenes[0].cameras.main.width,
                    height: newActiveScenes[0].cameras.main.height
                  });
                }
              }, 100);
            }
          } else {
            console.log('üîÑ Game or scene manager not ready for refresh');
          }
        } catch (error) {
          console.warn('Scene refresh error:', error.message);
        }
      }, delay);
    }

    // Update device metrics display
    function updateDeviceMetrics() {
      // Enhanced safety check for GameUtils availability
      console.log('Checking GameUtils...', typeof GameUtils);
      if (typeof GameUtils !== 'undefined') {
        console.log('GameUtils methods:', Object.getOwnPropertyNames(GameUtils));
      }
      
      if (typeof GameUtils === 'undefined' || !GameUtils.getMobileViewport) {
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Loading GameUtils...</strong><br>
          Waiting for game scripts to initialize...<br>
          <small>GameUtils type: ${typeof GameUtils}</small>
        `;
        return;
      }
      
      try {
        const viewport = GameUtils.getMobileViewport();
        const layout = GameUtils.getResponsiveLayout(viewport.width, viewport.height);
        const safeArea = GameUtils.getSafeAreaInsets();
        
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Viewport:</strong> ${viewport.width}√ó${viewport.height} (${viewport.aspectRatio.toFixed(2)}:1)<br>
          <strong>Font Scale:</strong> ${layout.fontScale}x | <strong>Device Type:</strong> ${viewport.isSmallDevice ? 'Small' : 'Standard'}<br>
          <strong>Safe Area:</strong> T:${safeArea.top} R:${safeArea.right} B:${safeArea.bottom} L:${safeArea.left}<br>
          <strong>Touch Targets:</strong> Min ${layout.minTouchTarget}px | <strong>Button Scale:</strong> ${layout.buttonScale}x
        `;
      } catch (error) {
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>Error:</strong> ${error.message}<br>
          Check console for details...<br>
          <small>GameUtils: ${typeof GameUtils}</small>
        `;
        console.error('GameUtils error:', error);
      }
    }

    // Test functions
    function toggleTestOverlay() {
      testOverlayVisible = !testOverlayVisible;
      const overlay = document.getElementById('testOverlay');
      overlay.classList.toggle('visible', testOverlayVisible);
    }

    function runLayoutValidation() {
      console.log('Running layout validation...', typeof GameUtils);
      
      if (typeof GameUtils === 'undefined' || !GameUtils.getMobileViewport) {
        document.getElementById('testResults').innerHTML = `
          GameUtils not loaded yet. Please wait...<br>
          <small>Type: ${typeof GameUtils}</small><br>
          <button onclick="updateDeviceMetrics(); runLayoutValidation();" style="margin-top:5px; padding:2px 6px; font-size:9px;">üîÑ Retry</button>
        `;
        return;
      }
      
      try {
        const results = [];
        const viewport = GameUtils.getMobileViewport();
        const layout = GameUtils.getResponsiveLayout(viewport.width, viewport.height);
        
        // Check button positioning
        if (layout.primaryButtonY > viewport.height - 100) {
          results.push('‚ùå Primary button too low');
        } else {
          results.push('‚úÖ Primary button positioned correctly');
        }
      
      // Check safe areas
      const safeArea = GameUtils.getSafeAreaInsets();
      if (layout.headerY > safeArea.top + 50) {
        results.push('‚úÖ Header respects safe area');
      } else {
        results.push('‚ö†Ô∏è Header may conflict with safe area');
      }
      
      // Check font scaling
      if (layout.fontScale >= 0.9 && layout.fontScale <= 1.2) {
        results.push('‚úÖ Font scaling within range');
      } else {
        results.push('‚ö†Ô∏è Font scaling may be extreme');
      }
      
      document.getElementById('testResults').innerHTML = results.join('<br>');
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Layout Validation Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Layout validation error:', error);
      }
    }

    function runPerformanceTest() {
      let frameCount = 0;
      let totalTime = 0;
      const startTime = performance.now();
      
      function measureFrames() {
        frameCount++;
        totalTime = performance.now() - startTime;
        
        if (totalTime >= 3000) { // 3 second test
          const avgFPS = Math.round((frameCount / totalTime) * 1000);
          const result = avgFPS >= 55 ? '‚úÖ' : avgFPS >= 45 ? '‚ö†Ô∏è' : '‚ùå';
          
          document.getElementById('testResults').innerHTML = `
            ${result} <strong>Performance Test Complete</strong><br>
            Average FPS: ${avgFPS}<br>
            Frames: ${frameCount} in ${Math.round(totalTime)}ms<br>
            Status: ${avgFPS >= 55 ? 'Excellent' : avgFPS >= 45 ? 'Good' : 'Needs Optimization'}
          `;
        } else {
          requestAnimationFrame(measureFrames);
        }
      }
      
      document.getElementById('testResults').innerHTML = 'Running 3-second performance test...';
      measureFrames();
    }

    function simulateGameplay() {
      if (!game || !game.scene || !game.scene.scenes) {
        document.getElementById('testResults').innerHTML = 'Game not loaded yet. Please wait...';
        return;
      }
      
      try {
        document.getElementById('testResults').innerHTML = `
          <strong>üéÆ Creating Full Game Screen with 9 Guesses:</strong><br>
          üì± This will show actual layout for MOBILE-006 testing<br>
          üîç Starting game scene...
        `;
        
        console.log('üéØ Debug: Starting game scene simulation');
        console.log('Available scenes:', game.scene.scenes.map(s => s.scene.key));
        
        // First, try to start the game scene directly
        game.scene.start('Game', { 
          difficulty: 'medium',
          testMode: true,
          populateTest: true
        });
        
        // Multiple retry attempts with better debugging
        let retryCount = 0;
        const maxRetries = 5;
        
        function attemptPopulation() {
          retryCount++;
          console.log(`üîÑ Population attempt ${retryCount}/${maxRetries}`);
          
          const gameScene = game.scene.getScene('Game');
          console.log('Game scene found:', !!gameScene);
          
          if (gameScene) {
            console.log('Game scene active:', gameScene.scene.isActive());
            console.log('Game scene visible:', gameScene.scene.isVisible());
            console.log('Game state exists:', !!gameScene.gameState);
            console.log('History renderer exists:', !!gameScene.historyRenderer);
            
            if (gameScene.scene.isActive() && gameScene.gameState) {
              populateGameWithGuesses(gameScene);
              return;
            }
          }
          
          document.getElementById('testResults').innerHTML += `<br>üîÑ Retry ${retryCount}: Scene not ready...`;
          
          if (retryCount < maxRetries) {
            setTimeout(attemptPopulation, 1000);
          } else {
            // Final fallback: try a simple approach
            document.getElementById('testResults').innerHTML += `<br>üîß Trying direct approach...`;
            createSimpleTestState();
          }
        }
        
        // Start the retry process
        setTimeout(attemptPopulation, 1500);
        
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Gameplay Simulation Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Gameplay simulation error:', error);
      }
    }
    
    function createSimpleTestState() {
      try {
        console.log('üîß Creating simple test state as fallback');
        
        // Just get to the game scene first
        game.scene.start('Game', { difficulty: 'medium' });
        
        setTimeout(() => {
          document.getElementById('testResults').innerHTML = `
            <strong>üéÆ Fallback Test Mode Active:</strong><br>
            ‚úÖ Game scene loaded<br>
            üéØ You can now manually test layout<br>
            üì± Make some guesses to see the layout<br>
            <br>
            <strong>Manual Testing:</strong><br>
            1. Play the game normally<br>
            2. Make several guesses<br>
            3. Observe layout at bottom<br>
            4. Test scroll behavior
          `;
        }, 2000);
        
      } catch (error) {
        console.error('Simple test state error:', error);
        document.getElementById('testResults').innerHTML += `<br>‚ùå Fallback failed: ${error.message}`;
      }
    }

    function populateGameWithGuesses(gameScene) {
      try {
        console.log('üéØ Populating game scene with 9 guesses...');
        
        // Define 9 complete guesses with realistic Christmas elements
        const testGuesses = [
          { guess: ['santa', 'tree', 'star', 'present'], feedback: [1, 0, 1, 0] },          // Row 1
          { guess: ['snowflake', 'candycane', 'mistletoe', 'tree'], feedback: [0, 1, 0, 1] }, // Row 2
          { guess: ['present', 'santa', 'snowflake', 'star'], feedback: [1, 1, 0, 0] },     // Row 3
          { guess: ['tree', 'mistletoe', 'santa', 'candycane'], feedback: [0, 0, 1, 1] },   // Row 4
          { guess: ['star', 'present', 'tree', 'snowflake'], feedback: [1, 0, 0, 1] },      // Row 5
          { guess: ['candycane', 'star', 'present', 'santa'], feedback: [0, 1, 1, 0] },     // Row 6
          { guess: ['mistletoe', 'snowflake', 'candycane', 'tree'], feedback: [1, 0, 0, 1] }, // Row 7
          { guess: ['present', 'tree', 'santa', 'star'], feedback: [0, 1, 0, 1] },          // Row 8
          { guess: ['snowflake', 'mistletoe', 'star', 'present'], feedback: [1, 1, 1, 0] }  // Row 9
        ];
        
        // Set up the game state to show all 9 guesses
        if (gameScene.gameState) {
          // Set current round to 10 (after 9 guesses)
          gameScene.gameState.currentRound = 10;
          gameScene.gameState.maxRounds = 13; // Medium difficulty
          
          // Initialize history array
          gameScene.gameState.history = [];
          
          // Populate history with all test guesses
          testGuesses.forEach((testGuess, index) => {
            gameScene.gameState.history.push({
              guess: [...testGuess.guess],
              feedback: [...testGuess.feedback],
              round: index + 1
            });
          });
          
          console.log('‚úÖ Game state populated with', gameScene.gameState.history.length, 'guesses');
          
          // Force the history renderer to update
          if (gameScene.historyRenderer) {
            gameScene.historyRenderer.renderHistory(gameScene.gameState.history);
            console.log('‚úÖ History renderer updated');
          }
          
          // Update the UI elements
          if (gameScene.updateUI) {
            gameScene.updateUI();
            console.log('‚úÖ UI updated');
          }
          
          // Make sure the active row is positioned correctly for round 10
          if (gameScene.activeRowManager) {
            gameScene.activeRowManager.updateRowPosition();
            console.log('‚úÖ Active row positioned for round 10');
          }
          
          // Update any round counter displays
          if (gameScene.roundText) {
            gameScene.roundText.setText(`Round: ${gameScene.gameState.currentRound}/${gameScene.gameState.maxRounds}`);
          }
          
          document.getElementById('testResults').innerHTML = `
            <strong>ÔøΩ Game Populated Successfully!</strong><br>
            ‚úÖ 9 completed guesses displayed<br>
            üéØ Round 10 active row ready<br>
            üì± Perfect for testing MOBILE-006 layout<br>
            <br>
            <strong>Test Now:</strong><br>
            1. Scroll down to see all guesses<br>
            2. Check submit button position<br>
            3. Test mobile scrolling behavior
          `;
          
        } else {
          throw new Error('Game state not available');
        }
        
      } catch (error) {
        document.getElementById('testResults').innerHTML += `<br>‚ùå Population error: ${error.message}`;
        console.error('Game population error:', error);
        
        // Fallback: Try to at least get to the game scene
        document.getElementById('testResults').innerHTML += `<br>üîÑ Falling back to basic game scene...`;
        game.scene.start('Game', { difficulty: 'medium' });
      }
    }

    function debugGameState() {
      if (!game) {
        document.getElementById('testResults').innerHTML = 'Game not initialized';
        return;
      }
      
      try {
        const scenes = game.scene.scenes.map(s => ({
          key: s.scene.key,
          active: s.scene.isActive(),
          visible: s.scene.isVisible(),
          status: s.scene.settings.status
        }));
        
        const activeScene = game.scene.scenes.find(s => s.scene.isActive());
        const gameScene = game.scene.getScene('Game');
        
        // Check if GameScene class is properly loaded
        const gameSceneClassExists = typeof GameScene !== 'undefined';
        
        document.getElementById('testResults').innerHTML = `
          <strong>üîç Debug Information:</strong><br>
          <strong>Scenes:</strong> ${scenes.map(s => `${s.key}(${s.active ? 'active' : 'inactive'}-${s.status})`).join(', ')}<br>
          <strong>Active Scene:</strong> ${activeScene ? activeScene.scene.key : 'None'}<br>
          <strong>GameScene Class:</strong> ${gameSceneClassExists ? 'Loaded' : 'Missing'}<br>
          <strong>GameScene Instance:</strong> ${!!gameScene}<br>
          ${gameScene ? `<strong>GameScene Active:</strong> ${gameScene.scene.isActive()}<br>` : ''}
          ${gameScene ? `<strong>GameScene Status:</strong> ${gameScene.scene.settings.status}<br>` : ''}
          ${gameScene ? `<strong>GameState Exists:</strong> ${!!gameScene.gameState}<br>` : ''}
          <strong>Game Object:</strong> ${typeof game}<br>
          <strong>Scene Manager:</strong> ${!!game.scene.manager}<br>
          <strong>Phaser Version:</strong> ${typeof Phaser !== 'undefined' ? 'Loaded' : 'Missing'}<br>
          <strong>GameUtils:</strong> ${typeof GameUtils !== 'undefined' ? 'Loaded' : 'Missing'}<br>
          <br>
          <button onclick="attemptDirectGameStart()" style="margin-top:5px; padding:4px 8px; font-size:10px; background:#e67e22; color:white; border:none; border-radius:3px;">üîß Try Direct Start</button>
        `;
        
        console.log('üîç Full debug info:', {
          scenes,
          activeScene: activeScene ? activeScene.scene.key : null,
          gameSceneClass: gameSceneClassExists,
          gameScene: !!gameScene,
          gameSceneActive: gameScene ? gameScene.scene.isActive() : false,
          gameSceneStatus: gameScene ? gameScene.scene.settings.status : 'N/A',
          gameState: gameScene ? !!gameScene.gameState : false
        });
        
        // Check if scripts are properly loaded
        console.log('üîç Script loading status:');
        console.log('- GameScene:', typeof GameScene);
        console.log('- GameStateManager:', typeof GameStateManager);
        console.log('- UILayoutManager:', typeof UILayoutManager);
        console.log('- ActiveRowManager:', typeof ActiveRowManager);
        
      } catch (error) {
        document.getElementById('testResults').innerHTML = `Debug error: ${error.message}`;
        console.error('Debug error:', error);
      }
    }
    
    function attemptDirectGameStart() {
      try {
        console.log('üîß Attempting direct game start...');
        
        // Force clear all scenes using correct Phaser API
        if (game && game.scene && game.scene.scenes) {
          game.scene.scenes.forEach(scene => {
            if (scene.scene.isActive()) {
              console.log(`üõë Force stopping: ${scene.scene.key}`);
              game.scene.stop(scene.scene.key);
            }
          });
        }
        
        setTimeout(() => {
          console.log('üéÆ Direct start of GameScene...');
          
          // Try multiple approaches
          if (typeof GameScene !== 'undefined') {
            game.scene.add('Game_Test', GameScene, true, { 
              difficulty: 'medium',
              maxRounds: 13,
              testMode: true 
            });
            
            setTimeout(() => {
              const testScene = game.scene.getScene('Game_Test');
              if (testScene && testScene.scene.isActive()) {
                document.getElementById('testResults').innerHTML += `<br>‚úÖ Direct start successful!`;
              } else {
                document.getElementById('testResults').innerHTML += `<br>‚ùå Direct start failed`;
              }
            }, 1000);
          } else {
            document.getElementById('testResults').innerHTML += `<br>‚ùå GameScene class not found`;
          }
        }, 100);
        
      } catch (error) {
        console.error('Direct start error:', error);
        document.getElementById('testResults').innerHTML += `<br>‚ùå Direct start error: ${error.message}`;
      }
    }

    function quickGameTest() {
      if (!game || !game.scene) {
        document.getElementById('testResults').innerHTML = 'Game not loaded yet. Please wait...';
        return;
      }
      
      try {
        document.getElementById('testResults').innerHTML = `
          <strong>üéØ Quick Game Test:</strong><br>
          üéÆ Starting game scene for manual testing<br>
          üì± Debugging scene transition...
        `;
        
        console.log('üéØ Quick Game Test - Available scenes:', game.scene.scenes.map(s => s.scene.key));
        
        // Get current active scenes using the correct Phaser API
        const currentActiveScenes = game.scene.scenes.filter(s => s.scene.isActive());
        console.log('üéØ Quick Game Test - Current active scenes:', currentActiveScenes.map(s => s.scene.key));
        
        // First stop all scenes to ensure clean start
        game.scene.scenes.forEach(scene => {
          if (scene.scene.isActive()) {
            console.log(`üõë Stopping active scene: ${scene.scene.key}`);
            game.scene.stop(scene.scene.key);
          }
        });
        
        // Wait a moment, then start difficulty selection first (proper flow)
        setTimeout(() => {
          console.log('üéØ Starting DifficultySelection scene...');
          game.scene.start('DifficultySelection');
          
          // Then automatically transition to game
          setTimeout(() => {
            console.log('üéØ Starting Game with medium difficulty...');
            game.scene.start('Game', { 
              difficulty: 'medium',
              maxRounds: 13,
              testMode: true
            });
            
            // Check if it worked
            setTimeout(() => {
              const gameScene = game.scene.getScene('Game');
              const isActive = gameScene && gameScene.scene.isActive();
              console.log('üîç Game scene started successfully:', isActive);
              
              if (isActive) {
                document.getElementById('testResults').innerHTML = `
                  <strong>üéØ Quick Game Test Active:</strong><br>
                  ‚úÖ Game scene loaded successfully<br>
                  üéÆ Make guesses manually to test layout<br>
                  üì± Check bottom layout issues<br>
                  üîç Test scroll behavior<br>
                  <br>
                  <strong>What to Look For:</strong><br>
                  ‚Ä¢ Submit button positioning<br>
                  ‚Ä¢ Layout at bottom of screen<br>
                  ‚Ä¢ Scroll responsiveness<br>
                  ‚Ä¢ Safe area handling
                `;
              } else {
                document.getElementById('testResults').innerHTML = `
                  <strong>‚ùå Quick Game Test Failed:</strong><br>
                  Game scene did not start properly<br>
                  <small>Check console for scene debugging info</small><br>
                  <button onclick="debugGameState()" style="margin-top:5px; padding:2px 6px; font-size:9px;">üîç Debug State</button>
                `;
              }
            }, 1000);
          }, 500);
        }, 200);
        
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Quick Test Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Quick game test error:', error);
      }
    }

    function testMobileScroll() {
      document.getElementById('testResults').innerHTML = `
        <strong>üì± Mobile Scroll Test:</strong><br>
        üéØ Testing swipe up/down functionality<br>
        üìã <strong>Current Issues to Check:</strong><br>
        ‚Ä¢ Bottom layout problems (submit button area)<br>
        ‚Ä¢ Scroll responsiveness on mobile<br>
        ‚Ä¢ Safe area handling during scroll<br>
        <br>
        <strong>Manual Test Steps:</strong><br>
        1. üéÆ First click "Populate 9 Guesses"<br>
        2. üëÜ Try swiping up and down<br>
        3. üì± Check if scrolling feels natural<br>
        4. üîç Look for layout issues at bottom<br>
        5. ‚úÖ Verify submit button accessibility<br>
        <br>
        <strong>üìã Future Task Needed:</strong><br>
        Add proper mobile swipe scroll functionality<br>
        for better mobile user experience
      `;
      
      // Add this to tasks for future work
      console.log('üìã FUTURE TASK: Implement mobile swipe scroll functionality');
      console.log('   - Easy up/down swiping for mobile users');
      console.log('   - Smooth scroll animations');
      console.log('   - Proper momentum scrolling');
    }

    function testMOBILE006() {
      if (typeof GameUtils === 'undefined' || !GameUtils.getSafeAreaInsets) {
        document.getElementById('testResults').innerHTML = 'GameUtils not loaded yet. Please wait...';
        return;
      }
      
      try {
        const safeArea = GameUtils.getSafeAreaInsets();
        const layout = GameUtils.getResponsiveLayout();
        
        // Check if we're in game scene for more accurate testing
        const currentScene = game && game.scene ? game.scene.scenes.find(s => s.scene.isActive()) : null;
        const isInGameScene = currentScene && (currentScene.constructor.name === 'GameScene' || currentScene.scene.key === 'Game');
        
        // Test browser UI overlap prevention
        const hasValidSafeArea = safeArea.bottom > 0;
        const submitButtonPosition = layout.contentEndY;
        const screenHeight = window.innerHeight;
        const visualHeight = window.visualViewport ? window.visualViewport.height : screenHeight;
        
        // Calculate if submit button would be covered by browser UI
        const browserUIOverlap = screenHeight - visualHeight;
        const submitSafety = submitButtonPosition + safeArea.bottom < visualHeight;
        
        document.getElementById('testResults').innerHTML = `
          <strong>üîß MOBILE-006 Browser UI Overlap Fix Test:</strong><br>
          ${hasValidSafeArea ? '‚úÖ' : '‚ùå'} Safe area detection: ${hasValidSafeArea ? 'Working' : 'Failed'}<br>
          ${isInGameScene ? 'üéÆ' : 'üì±'} Current scene: ${isInGameScene ? 'Game (ideal for testing)' : 'Menu (use Simulate Game first)'}<br>
          üìè Submit button Y: ${submitButtonPosition}px<br>
          üì± Visual viewport: ${visualHeight}px (vs ${screenHeight}px)<br>
          üîí Safe area bottom: ${safeArea.bottom}px<br>
          ${submitSafety ? '‚úÖ' : '‚ö†Ô∏è'} Submit accessibility: ${submitSafety ? 'Protected' : 'May be covered'}<br>
          <br>
          <strong>Test Instructions:</strong><br>
          ${isInGameScene ? '1. ‚úÖ Already in game - perfect!' : '1. üéÆ Click "Simulate Game" first for best testing'}<br>
          2. üì± Scroll up to show address bar<br>
          3. üéØ Make element selections<br>
          4. üëÜ Try tapping submit button<br>
          5. ‚úÖ Button should remain accessible<br>
          <br>
          <strong>Expected Results:</strong><br>
          ‚Ä¢ Submit button stays above browser UI<br>
          ‚Ä¢ Safe area padding prevents overlap<br>
          ‚Ä¢ Game remains playable with address bar visible
        `;
        
        // Also highlight the safe area visually
        const indicators = document.querySelectorAll('.safe-area-indicator');
        indicators.forEach(indicator => {
          indicator.style.opacity = '0.7';
          indicator.style.background = '#e74c3c';
        });
        
        setTimeout(() => {
          indicators.forEach(indicator => {
            indicator.style.opacity = '0.3';
            indicator.style.background = '#3498db';
          });
        }, 3000);
        
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>MOBILE-006 Test Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('MOBILE-006 test error:', error);
      }
    }

    function testTouchTargets() {
      // This would need integration with actual game scenes
      document.getElementById('testResults').innerHTML = `
        <strong>Touch Target Guidelines:</strong><br>
        ‚úÖ Minimum size: 44px √ó 44px<br>
        ‚úÖ Spacing: 12px between targets<br>
        üì± Test by tapping buttons in-game<br>
        üí° Check accessibility compliance
      `;
    }

    function testSafeAreas() {
      if (typeof GameUtils === 'undefined' || !GameUtils.getSafeAreaInsets) {
        document.getElementById('testResults').innerHTML = 'GameUtils not loaded yet. Please wait...';
        return;
      }
      
      try {
        const safeArea = GameUtils.getSafeAreaInsets();
        const hasNotch = safeArea.top > 20 || safeArea.bottom > 20;
        
        document.getElementById('testResults').innerHTML = `
          <strong>Safe Area Detection:</strong><br>
          ${hasNotch ? 'üì±' : 'üì±'} Device: ${hasNotch ? 'Has notch/home indicator' : 'Standard bezels'}<br>
          üìê Insets: ${safeArea.top}/${safeArea.right}/${safeArea.bottom}/${safeArea.left}<br>
          ${safeArea.top > 0 ? '‚úÖ' : '‚ùì'} CSS env() support: ${safeArea.top > 0 ? 'Working' : 'Check implementation'}
        `;
      } catch (error) {
        document.getElementById('testResults').innerHTML = `
          <strong>Safe Area Test Error:</strong> ${error.message}<br>
          Check console for details...
        `;
        console.error('Safe area test error:', error);
      }
    }

    function testTextWrapping() {
      document.getElementById('testResults').innerHTML = `
        <strong>Text Wrapping Test:</strong><br>
        üìù Navigate to game over screen to test score explanation wrapping<br>
        üì± Check that long text fits within screen bounds<br>
        ‚úÖ Should use multiple lines instead of horizontal overflow<br>
        üí° Font should scale appropriately for device size
      `;
    }

    // Initialize
    window.addEventListener('load', () => {
      console.log('Window loaded, checking scripts...');
      
      // Hide TEST MODE overlay that blocks the Tests button
      setTimeout(() => {
        // Try multiple methods to find and hide the TEST MODE overlay
        const overlays = document.querySelectorAll('div');
        overlays.forEach(overlay => {
          const style = window.getComputedStyle(overlay);
          const text = overlay.textContent || overlay.innerText;
          
          if ((text.includes('TEST MODE') || text.includes('Screen:') || text.includes('DPR:')) && 
              (style.position === 'fixed' || style.position === 'absolute') &&
              (overlay.style.zIndex > 1000 || style.zIndex > 1000)) {
            overlay.style.display = 'none';
            console.log('üéØ Hidden TEST MODE overlay:', text.substring(0, 50));
          }
        });
        
        // Also try to hide by common test overlay patterns
        const testOverlays = document.querySelectorAll('[style*="position: fixed"], [style*="z-index"]');
        testOverlays.forEach(overlay => {
          const text = overlay.textContent || '';
          if (text.includes('TEST') || text.includes('Screen:') || text.includes('DPR:')) {
            overlay.style.display = 'none';
            console.log('üéØ Hidden test overlay via pattern matching');
          }
        });
      }, 200);
      
      // Keep checking for test overlays that might appear later
      setInterval(() => {
        const overlays = document.querySelectorAll('div[style*="position: fixed"], div[style*="position: absolute"]');
        overlays.forEach(overlay => {
          const text = overlay.textContent || '';
          if (text.includes('TEST MODE') || text.includes('Screen:') || text.includes('DPR:')) {
            if (overlay.style.display !== 'none') {
              overlay.style.display = 'none';
              console.log('üîÑ Continuously hidden test overlay');
            }
          }
        });
      }, 1000);
      
      // Debug script loading
      console.log('Available classes:');
      console.log('- Phaser:', typeof Phaser);
      console.log('- TestConfig:', typeof TestConfig);
      console.log('- GameUtils:', typeof GameUtils);
      console.log('- GameStateManager:', typeof GameStateManager);
      console.log('- MainMenu:', typeof MainMenu);
      
      // Debug GameUtils methods specifically
      if (typeof GameUtils !== 'undefined') {
        console.log('GameUtils methods:', Object.getOwnPropertyNames(GameUtils));
        console.log('GameUtils prototype methods:', Object.getOwnPropertyNames(GameUtils.prototype));
        console.log('All GameUtils properties:', Object.getOwnPropertyDescriptors(GameUtils));
        console.log('Checking mobile methods:');
        console.log('- getMobileViewport:', typeof GameUtils.getMobileViewport);
        console.log('- getResponsiveLayout:', typeof GameUtils.getResponsiveLayout);
        console.log('- getSafeAreaInsets:', typeof GameUtils.getSafeAreaInsets);
        
        // Test calling the method
        try {
          const testViewport = GameUtils.getMobileViewport();
          console.log('‚úÖ getMobileViewport works:', testViewport);
        } catch (error) {
          console.error('‚ùå getMobileViewport failed:', error);
        }
      }
      
      // Check if GameUtils.js actually loaded
      if (typeof GameUtils === 'undefined') {
        console.error('‚ùå GameUtils is undefined - script failed to load');
        document.getElementById('deviceMetrics').innerHTML = `
          <strong>‚ùå GameUtils Script Failed</strong><br>
          Check Network tab for 404 errors<br>
          <small>Path: ../js/utils/GameUtils.js</small>
        `;
        document.getElementById('testResults').innerHTML = `
          <strong>Script Loading Debug:</strong><br>
          Phaser: ${typeof Phaser}<br>
          TestConfig: ${typeof TestConfig}<br>
          GameUtils: ${typeof GameUtils}<br>
          Check browser Network tab for failed requests
        `;
        return;
      }
      
      // Wait longer for all scripts to initialize
      setTimeout(() => {
        try {
          console.log('Initializing game...');
          
          // Set up default device simulation BEFORE game initialization
          if (typeof GameUtils !== 'undefined') {
            GameUtils._simulatedViewport = {
              width: defaultDevice.width,
              height: defaultDevice.height,
              devicePixelRatio: window.devicePixelRatio || 1,
              aspectRatio: defaultDevice.width / defaultDevice.height,
              isSmallDevice: defaultDevice.width <= 375,
              isStandardDevice: defaultDevice.width >= 414 && defaultDevice.width <= 428,
              orientation: defaultDevice.height > defaultDevice.width ? 'portrait' : 'landscape'
            };
            console.log(`üéØ Pre-initialized simulated viewport:`, GameUtils._simulatedViewport);
          }
          
          game = new Phaser.Game(config);
          
          // Set up device simulation UI after game loads
          setTimeout(() => {
            setDeviceSize(defaultDevice.width, defaultDevice.height);
          }, 100);
          
          updateFPS();
          updateDeviceMetrics();
          
          // Auto-hide overlay after 5 seconds
          setTimeout(() => {
            if (testOverlayVisible) toggleTestOverlay();
          }, 5000);
        } catch (error) {
          console.error('Game initialization error:', error);
          document.getElementById('testResults').innerHTML = `
            <strong>Initialization Error:</strong> ${error.message}<br>
            Check console for details...
          `;
        }
      }, 500);
    });

    // Handle viewport changes
    window.addEventListener('resize', () => {
      console.log('üîÑ Window resized, updating metrics');
      updateDeviceMetrics();
      
      // If in full screen mode, resize game to match
      const container = document.getElementById('game-container');
      if (container.style.width === '100vw' || !container.style.width) {
        if (game) {
          const width = window.innerWidth;
          const height = window.innerHeight;
          console.log(`üéÆ Auto-resizing game to: ${width}√ó${height}`);
          game.scale.resize(width, height);
        }
      }
    });

    // Prevent zoom on mobile
    document.addEventListener('touchstart', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // Reset to full screen mode
    function resetToFullScreen() {
      document.querySelectorAll('.device-button').forEach(btn => btn.classList.remove('active'));
      
      console.log('üñ•Ô∏è Resetting to full screen mode');
      
      const container = document.getElementById('game-container');
      
      // Reset all simulation styles completely
      container.style.width = '100vw';
      container.style.height = '100vh';
      container.style.margin = '0';
      container.style.border = 'none';
      container.style.borderRadius = '0';
      container.style.transform = '';
      container.style.transformOrigin = '';
      container.style.overflow = 'hidden';
      container.style.position = 'static';
      container.style.boxShadow = 'none';
      
      // Remove CSS class for device simulation
      container.classList.remove('device-simulation');
      
      // DON'T reset viewport meta - leave it as originally set
      
      // Reset body overflow
      document.body.style.overflow = 'hidden';
      
      // Resize game back to full screen
      if (game) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        console.log(`üéÆ Resizing game back to full screen: ${width}√ó${height}`);
        
        // Clear simulated viewport
        if (typeof GameUtils !== 'undefined') {
          GameUtils._simulatedViewport = null;
          console.log(`üéØ Cleared simulated viewport for GameUtils`);
        }
        
        game.scale.resize(width, height);
        
        // Reset canvas styles to original
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            // Restore original CSS rules with !important
            canvas.style.setProperty('width', '100vw', 'important');
            canvas.style.setProperty('height', '100vh', 'important');
            canvas.style.setProperty('position', 'fixed', 'important');
            canvas.style.setProperty('top', '0', 'important');
            canvas.style.setProperty('left', '0', 'important');
            canvas.style.removeProperty('max-width');
            canvas.style.removeProperty('max-height');
            
            console.log(`üéØ Canvas reset to full screen: ${width}√ó${height}`);
            console.log(`üéØ Canvas computed style: ${getComputedStyle(canvas).width} √ó ${getComputedStyle(canvas).height}`);
          }
        }, 50);
        
        // Trigger scene refresh
        safeSceneRefresh(game, 150);
      }
      
      updateDeviceMetrics();
      
      document.getElementById('testResults').innerHTML = `
        <strong>Full Screen Mode:</strong><br>
        üñ•Ô∏è Device simulation disabled<br>
        üì± Using actual device viewport<br>
        üéØ Testing native mobile experience
      `;
    }
  </script>
</body>
</html>
