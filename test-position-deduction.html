<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Position-Specific Deduction Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #00ff00;
        }
        .test-case {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #00ff00;
            background: #0a0a0a;
        }
        .test-case.pass {
            border-color: #00ff00;
        }
        .test-case.fail {
            border-color: #ff0000;
            color: #ff0000;
        }
        .code {
            color: #ffff00;
            font-weight: bold;
        }
        .guess {
            color: #00ffff;
        }
        .position {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            background: #000;
            border: 1px solid #00ff00;
        }
        .eliminated {
            text-decoration: line-through;
            opacity: 0.5;
        }
        h1, h2 {
            color: #00ff00;
        }
        .note {
            color: #ffaa00;
            font-style: italic;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üéØ Position-Specific Deduction Tests</h1>
    <div class="note">
        These tests check if elements are eliminated from SPECIFIC POSITIONS,<br>
        not just globally eliminated from the entire code.
    </div>
    <div id="test-results"></div>

    <script src="js/utils/LogicDeductionEngine.js"></script>
    <script>
        const results = document.getElementById('test-results');

        function calculateFeedback(guess, code) {
            let black = 0;
            let white = 0;
            const codeCopy = [...code];
            const guessCopy = [...guess];

            for (let i = 0; i < guess.length; i++) {
                if (guessCopy[i] === codeCopy[i]) {
                    black++;
                    codeCopy[i] = null;
                    guessCopy[i] = null;
                }
            }

            for (let i = 0; i < guess.length; i++) {
                if (guessCopy[i] !== null) {
                    const idx = codeCopy.indexOf(guessCopy[i]);
                    if (idx !== -1) {
                        white++;
                        codeCopy[idx] = null;
                    }
                }
            }

            return {black, white};
        }

        function runPositionTest(testName, code, guesses, expectedPossible) {
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';

            let html = `<h2>Test: ${testName}</h2>`;
            html += `<div class="code">Secret Code: [${code.join(', ')}]</div><br>`;

            const allElements = ['Santa', 'Present', 'Candy Cane', 'Star', 'Tree', 'Snowflake'];
            const engine = new LogicDeductionEngine(code.length, allElements);

            guesses.forEach((guess, idx) => {
                const feedback = calculateFeedback(guess, code);
                html += `<div class="guess">Guess ${idx + 1}: [${guess.join(', ')}] ‚Üí ${feedback.black} black, ${feedback.white} white</div>`;
                engine.analyzeGuess(guess, feedback);
            });

            html += '<br><h3>Possible Elements by Position:</h3>';
            let allPass = true;

            for (let pos = 0; pos < code.length; pos++) {
                const actual = engine.getPossibleElements(pos);
                const expected = expectedPossible[pos];

                const posPass = JSON.stringify(actual.sort()) === JSON.stringify(expected.sort());
                if (!posPass) allPass = false;

                html += `<div><strong>Position ${pos}:</strong> `;
                html += `Expected: [${expected.join(', ')}] `;
                html += `| Actual: [${actual.join(', ')}] `;
                html += posPass ? '‚úÖ' : '‚ùå';
                html += '</div>';
            }

            html += `<div><strong>Overall Result:</strong> ${allPass ? '‚úÖ PASS' : '‚ùå FAIL'}</div>`;

            testDiv.className = allPass ? 'test-case pass' : 'test-case fail';
            testDiv.innerHTML = html;
            results.appendChild(testDiv);

            return allPass;
        }

        console.log('üß™ Running Position-Specific Tests...\n');

        let passCount = 0;
        let totalTests = 0;

        // TEST 1: Simple - element tried at position and gets 0 feedback (all same)
        totalTests++;
        if (runPositionTest(
            'TEST 1: Global Elimination (Baseline)',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                ['Candy Cane', 'Candy Cane', 'Candy Cane', 'Candy Cane'],  // 0 feedback
            ],
            [
                // Candy Cane should be eliminated from ALL positions
                ['Santa', 'Present', 'Star', 'Tree', 'Snowflake'],  // Position 0
                ['Santa', 'Present', 'Star', 'Tree', 'Snowflake'],  // Position 1
                ['Santa', 'Present', 'Star', 'Tree', 'Snowflake'],  // Position 2
                ['Santa', 'Present', 'Star', 'Tree', 'Snowflake'],  // Position 3
            ]
        )) passCount++;

        // TEST 2: Position-specific - element appears once, gets 1 black
        // We know it's IN the code, but at which position?
        // ADVANCED: We'd need multiple guesses to narrow this down
        totalTests++;
        if (runPositionTest(
            'TEST 2: Single Element Position Deduction',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                ['Santa', 'Santa', 'Santa', 'Santa'],  // 1 black ‚Üí Santa is at ONE position
                // After this, we CANNOT eliminate Santa from any specific position yet
                // We'd need more guesses to determine WHERE
            ],
            [
                // Santa should still be possible at all positions (we don't know which one)
                ['Candy Cane', 'Present', 'Santa', 'Star', 'Tree', 'Snowflake'],
                ['Candy Cane', 'Present', 'Santa', 'Star', 'Tree', 'Snowflake'],
                ['Candy Cane', 'Present', 'Santa', 'Star', 'Tree', 'Snowflake'],
                ['Candy Cane', 'Present', 'Santa', 'Star', 'Tree', 'Snowflake'],
            ]
        )) passCount++;

        // TEST 3: HYBRID DEDUCTION - Compare two guesses + lock when certain
        // Hybrid approach: Eliminate what's wrong, LOCK when highly certain
        totalTests++;
        if (runPositionTest(
            'TEST 3: Position Elimination + Hybrid Locking',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                ['Santa', 'Candy Cane', 'Candy Cane', 'Candy Cane'],  // 1 black (Santa at pos 0)
                ['Candy Cane', 'Santa', 'Candy Cane', 'Candy Cane'],  // 0 black (Santa NOT at pos 1)
                // Logic:
                // 1. Zero-black rule: Eliminate Candy Cane from pos 0,2,3 and Santa from pos 1
                // 2. Comparison rule: Santa at pos 0 (1 black) vs pos 1 (0 black) ‚Üí Santa is at pos 0
                // 3. Hybrid locking: Santa now only fits at position 0 ‚Üí LOCK it there!
            ],
            [
                // Position 0: LOCKED to Santa (only position it fits after elimination)
                ['Santa'],  // Hybrid approach locks when certain!
                // Position 1: Santa eliminated (tried there, got 0 black)
                ['Present', 'Candy Cane', 'Star', 'Tree', 'Snowflake'],
                // Position 2: Candy Cane eliminated (tried there, got 0 black)
                ['Present', 'Star', 'Tree', 'Snowflake'],
                // Position 3: Candy Cane eliminated (tried there, got 0 black)
                ['Present', 'Star', 'Tree', 'Snowflake'],
            ]
        )) passCount++;

        // TEST 4: Check if our current simple logic at least handles global elimination
        totalTests++;
        if (runPositionTest(
            'TEST 4: Multiple Global Eliminations',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                ['Candy Cane', 'Candy Cane', 'Candy Cane', 'Candy Cane'],  // 0 ‚Üí eliminate Candy
                ['Snowflake', 'Snowflake', 'Snowflake', 'Snowflake'],     // 0 ‚Üí eliminate Snowflake
            ],
            [
                // Both Candy Cane and Snowflake should be gone from all positions
                ['Present', 'Santa', 'Star', 'Tree'],
                ['Present', 'Santa', 'Star', 'Tree'],
                ['Present', 'Santa', 'Star', 'Tree'],
                ['Present', 'Santa', 'Star', 'Tree'],
            ]
        )) passCount++;

        // Summary
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'test-case';
        summaryDiv.innerHTML = `
            <h2>üìä Test Summary</h2>
            <div><strong>Total Tests:</strong> ${totalTests}</div>
            <div><strong>Passed:</strong> ${passCount}</div>
            <div><strong>Failed:</strong> ${totalTests - passCount}</div>
            <div><strong>Success Rate:</strong> ${Math.round(passCount / totalTests * 100)}%</div>
            <br>
            <div class="note">
                <strong>Note:</strong> Tests use HYBRID DEDUCTION approach:<br>
                - Eliminates elements from positions where they're proven wrong<br>
                - LOCKS positions when narrowed to 1 element (high certainty)<br>
                - Helps players when stuck, but preserves challenge<br>
                - All tests should pass with hybrid logic enabled
            </div>
        `;
        results.appendChild(summaryDiv);

        console.log(`\nüìä Test Results: ${passCount}/${totalTests} passed`);
    </script>
</body>
</html>
