<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Gameplay Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #00ff00;
        }
        .test-case {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #00ff00;
            background: #0a0a0a;
        }
        .test-case.pass {
            border-color: #00ff00;
        }
        .test-case.fail {
            border-color: #ff0000;
            color: #ff0000;
        }
        .code {
            color: #ffff00;
            font-weight: bold;
        }
        .guess {
            color: #00ffff;
            margin: 5px 0;
        }
        .deduction {
            color: #ff00ff;
            margin-left: 20px;
            font-size: 0.9em;
        }
        h1, h2, h3 {
            color: #00ff00;
        }
        .note {
            color: #ffaa00;
            font-style: italic;
            margin: 10px 0;
        }
        .summary {
            background: #000;
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid #00ff00;
        }
    </style>
</head>
<body>
    <h1>üéÆ Comprehensive Gameplay Tests</h1>
    <div class="note">
        Realistic MasterMind gameplay simulations with 8-10 turns.<br>
        Tests cumulative deduction logic across multiple guesses with mixed feedback.
    </div>
    <div id="test-results"></div>

    <script src="js/utils/LogicDeductionEngine.js"></script>
    <script>
        const results = document.getElementById('test-results');

        function calculateFeedback(guess, code) {
            let black = 0;
            let white = 0;
            const codeCopy = [...code];
            const guessCopy = [...guess];

            for (let i = 0; i < guess.length; i++) {
                if (guessCopy[i] === codeCopy[i]) {
                    black++;
                    codeCopy[i] = null;
                    guessCopy[i] = null;
                }
            }

            for (let i = 0; i < guess.length; i++) {
                if (guessCopy[i] !== null) {
                    const idx = codeCopy.indexOf(guessCopy[i]);
                    if (idx !== -1) {
                        white++;
                        codeCopy[idx] = null;
                    }
                }
            }

            return {black, white};
        }

        function runGameplayTest(testName, code, guesses, checkpoints) {
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';

            let html = `<h2>üéØ ${testName}</h2>`;
            html += `<div class="code">Secret Code: [${code.join(', ')}]</div><br>`;

            const allElements = ['Santa', 'Present', 'Candy Cane', 'Star', 'Tree', 'Snowflake'];
            const engine = new LogicDeductionEngine(code.length, allElements);

            let allPass = true;

            guesses.forEach((guess, idx) => {
                const feedback = calculateFeedback(guess, code);
                html += `<div class="guess">Turn ${idx + 1}: [${guess.join(', ')}] ‚Üí ${feedback.black}‚ö´ ${feedback.white}‚ö™</div>`;

                engine.analyzeGuess(guess, feedback);

                // Show deduction progress
                const deduced = engine.getDeducedPositions();
                if (deduced.length > 0) {
                    html += `<div class="deduction">üîí Locked: `;
                    deduced.forEach(pos => {
                        const element = engine.getDeducedElement(pos);
                        html += `Pos ${pos}=${element} `;
                    });
                    html += `</div>`;
                }

                const eliminated = Array.from(engine.eliminatedElements);
                if (eliminated.length > 0) {
                    html += `<div class="deduction">‚ùå Eliminated: ${eliminated.join(', ')}</div>`;
                }

                // Check checkpoint if defined for this turn
                if (checkpoints[idx]) {
                    const checkpoint = checkpoints[idx];
                    let checkPass = true;

                    // Check eliminated elements
                    if (checkpoint.eliminated) {
                        const actualEliminated = Array.from(engine.eliminatedElements).sort();
                        const expectedEliminated = [...checkpoint.eliminated].sort();
                        if (JSON.stringify(actualEliminated) !== JSON.stringify(expectedEliminated)) {
                            checkPass = false;
                            html += `<div class="deduction" style="color: #ff0000;">‚ùå Expected eliminated: ${expectedEliminated.join(', ')}</div>`;
                        }
                    }

                    // Check deduced positions
                    if (checkpoint.deducedPositions) {
                        const actualDeduced = engine.getDeducedPositions().sort();
                        const expectedDeduced = [...checkpoint.deducedPositions].sort();
                        if (JSON.stringify(actualDeduced) !== JSON.stringify(expectedDeduced)) {
                            checkPass = false;
                            html += `<div class="deduction" style="color: #ff0000;">‚ùå Expected deduced positions: ${expectedDeduced.join(', ')}</div>`;
                        }
                    }

                    // Check specific position possibilities
                    if (checkpoint.positionPossibilities) {
                        checkpoint.positionPossibilities.forEach(({position, maxPossible}) => {
                            const actual = engine.getPossibilityCount(position);
                            if (actual > maxPossible) {
                                checkPass = false;
                                html += `<div class="deduction" style="color: #ff0000;">‚ùå Pos ${position} has ${actual} possibilities (expected ‚â§${maxPossible})</div>`;
                            }
                        });
                    }

                    if (!checkPass) allPass = false;
                }

                html += '<br>';
            });

            // Final state summary
            html += '<div class="summary"><h3>Final Deduction State:</h3>';
            for (let i = 0; i < code.length; i++) {
                const possible = engine.getPossibleElements(i);
                const isDeduced = possible.length === 1;
                html += `<div><strong>Position ${i}:</strong> [${possible.join(', ')}]`;
                if (isDeduced) html += ' üîí';
                html += `</div>`;
            }
            html += `</div>`;

            html += `<div><strong>Test Result:</strong> ${allPass ? '‚úÖ PASS' : '‚ùå FAIL'}</div>`;

            testDiv.className = allPass ? 'test-case pass' : 'test-case fail';
            testDiv.innerHTML = html;
            results.appendChild(testDiv);

            return allPass;
        }

        console.log('üß™ Running Comprehensive Gameplay Tests...\n');

        let passCount = 0;
        let totalTests = 0;

        // TEST 1: Easy Win - Progressive narrowing with good guesses
        totalTests++;
        if (runGameplayTest(
            'Easy Win - Good Guessing Strategy',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                // Turn 1: Try common elements
                ['Santa', 'Present', 'Candy Cane', 'Snowflake'],
                // Turn 2: Got 2 blacks, 2 whites - some correct!
                ['Santa', 'Present', 'Star', 'Tree'],
                // Turn 3: Got 0 blacks, 4 whites! All elements confirmed, all wrong positions
                // Hybrid logic should FULLY DEDUCE from comparison of turns 2 & 3
                ['Present', 'Santa', 'Star', 'Tree'],
                // Turns 4-5: Already solved, just verifying
                ['Santa', 'Tree', 'Present', 'Star'],
                ['Santa', 'Star', 'Tree', 'Present'],
            ],
            {
                // After turn 3, Candy Cane & Snowflake eliminated, all positions deduced!
                2: { eliminated: ['Candy Cane', 'Snowflake'] },
                3: { deducedPositions: [0, 1, 2, 3] } // All positions solved!
            }
        )) passCount++;

        // TEST 2: Hard Puzzle - Mixed feedback, careful deduction needed
        totalTests++;
        if (runGameplayTest(
            'Hard Puzzle - Mixed Feedback Pattern',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                // Turn 1: Bad first guess
                ['Candy Cane', 'Snowflake', 'Snowflake', 'Candy Cane'],
                // Turn 2: Still exploring
                ['Tree', 'Santa', 'Present', 'Star'],
                // Turn 3: Got 1 black, 3 white - but which is black?
                ['Tree', 'Tree', 'Tree', 'Tree'],
                // Turn 4: Identify exact count (1 Tree)
                ['Star', 'Star', 'Star', 'Star'],
                // Turn 5: Identify exact count (1 Star)
                ['Present', 'Present', 'Present', 'Present'],
                // Turn 6: Identify exact count (1 Present)
                ['Santa', 'Santa', 'Santa', 'Santa'],
                // Turn 7: Identify exact count (1 Santa)
                ['Tree', 'Present', 'Star', 'Santa'],
                // Turn 8: Narrow down positions
            ],
            {
                1: { eliminated: ['Candy Cane', 'Snowflake'] },
                6: { eliminated: ['Candy Cane', 'Snowflake'] },
                7: { positionPossibilities: [{position: 0, maxPossible: 3}] }
            }
        )) passCount++;

        // TEST 3: All Whites Strategy - Confirm elements first
        totalTests++;
        if (runGameplayTest(
            'All Whites Strategy - Element Confirmation',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                // Turn 1: Random guess
                ['Present', 'Santa', 'Star', 'Tree'],
                // Turn 2: Got 4 whites! All elements confirmed, wrong positions
                ['Santa', 'Present', 'Tree', 'Star'],
                // Turn 3: Try positions
                ['Tree', 'Star', 'Santa', 'Present'],
                // Turn 4: Getting closer
                ['Star', 'Tree', 'Present', 'Santa'],
                // Turn 5: Should narrow significantly
            ],
            {
                1: { eliminated: ['Candy Cane', 'Snowflake'] },
                2: { deducedPositions: [] }, // Still figuring out positions
                4: { positionPossibilities: [{position: 0, maxPossible: 3}] }
            }
        )) passCount++;

        // TEST 4: Elimination Focus - Rule out elements systematically
        totalTests++;
        if (runGameplayTest(
            'Elimination Focus - Systematic Approach',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                // Turn 1: Test potential elements
                ['Candy Cane', 'Candy Cane', 'Candy Cane', 'Candy Cane'],
                // Turn 2: Eliminate globally
                ['Snowflake', 'Snowflake', 'Snowflake', 'Snowflake'],
                // Turn 3: Eliminate globally
                ['Santa', 'Santa', 'Santa', 'Santa'],
                // Turn 4: Confirm exact count (1 Santa)
                ['Present', 'Present', 'Present', 'Present'],
                // Turn 5: Confirm exact count (1 Present)
                ['Tree', 'Present', 'Santa', 'Star'],
                // Turn 6: Start testing positions
                ['Santa', 'Tree', 'Star', 'Present'],
                // Turn 7: Swap positions
                ['Present', 'Star', 'Tree', 'Santa'],
                // Turn 8: Continue narrowing
            ],
            {
                2: { eliminated: ['Candy Cane', 'Snowflake'] },
                5: { eliminated: ['Candy Cane', 'Snowflake'] },
                7: { positionPossibilities: [{position: 0, maxPossible: 3}] }
            }
        )) passCount++;

        // TEST 5: Single Element Movement - Position comparison
        totalTests++;
        if (runGameplayTest(
            'Single Element Movement - Position Deduction',
            ['Santa', 'Present', 'Tree', 'Star'],
            [
                // Turn 1: Santa at position 0
                ['Santa', 'Candy Cane', 'Candy Cane', 'Candy Cane'],
                // Turn 2: Got 1 black, Santa is at position 0
                ['Candy Cane', 'Santa', 'Candy Cane', 'Candy Cane'],
                // Turn 3: Got 0 black, 1 white - Santa NOT at position 1!
                // This should LOCK Santa at position 0 via comparison
                ['Snowflake', 'Present', 'Tree', 'Star'],
                // Turn 4: Try remaining positions
            ],
            {
                2: {
                    eliminated: ['Candy Cane'],
                    deducedPositions: [0] // Santa locked at position 0 via comparison
                },
                3: { eliminated: ['Candy Cane', 'Snowflake'] }
            }
        )) passCount++;

        // TEST 6: Duplicate Elements - Critical edge case
        totalTests++;
        if (runGameplayTest(
            'Duplicate Elements - Santa Appears Twice',
            ['Snowflake', 'Santa', 'Candy Cane', 'Santa', 'Present'],
            [
                // Turn 1: Try all Santas to identify count
                ['Santa', 'Santa', 'Santa', 'Santa', 'Santa'],
                // Turn 2: Got 2 feedback ‚Üí exactly 2 Santas in code
                ['Snowflake', 'Santa', 'Candy Cane', 'Tree', 'Present'],
                // Turn 3: 4 blacks! Very close, Tree is wrong
                ['Snowflake', 'Santa', 'Candy Cane', 'Santa', 'Present'],
                // Turn 4: Should be solved - 2 Santas at positions 1 & 3
            ],
            {
                1: {}, // After all-same guess, know exact count
                2: { eliminated: ['Tree'] }, // Tree got 0 feedback
                3: {
                    deducedPositions: [0, 1, 2, 3, 4], // All positions deduced!
                    // CRITICAL: Santa must be possible at BOTH positions 1 and 3
                }
            }
        )) passCount++;

        // Summary
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'test-case';
        summaryDiv.innerHTML = `
            <h2>üìä Test Summary</h2>
            <div><strong>Total Tests:</strong> ${totalTests}</div>
            <div><strong>Passed:</strong> ${passCount}</div>
            <div><strong>Failed:</strong> ${totalTests - passCount}</div>
            <div><strong>Success Rate:</strong> ${Math.round(passCount / totalTests * 100)}%</div>
            <br>
            <div class="note">
                <strong>Comprehensive Gameplay Tests:</strong><br>
                ‚úÖ Easy Win: Progressive narrowing with good strategy<br>
                ‚úÖ Hard Puzzle: Mixed feedback requiring careful deduction<br>
                ‚úÖ All Whites: Element confirmation before position finding<br>
                ‚úÖ Elimination Focus: Systematic ruling out of elements<br>
                ‚úÖ Single Movement: Position comparison via element movement<br>
                ‚úÖ Duplicate Elements: Handles elements appearing multiple times<br>
                <br>
                These tests simulate realistic family gameplay patterns<br>
                with 4-8 turns of mixed blacks and whites.<br>
                Includes critical edge case: duplicate elements!
            </div>
        `;
        results.appendChild(summaryDiv);

        console.log(`\nüìä Test Results: ${passCount}/${totalTests} passed (${Math.round(passCount / totalTests * 100)}%)`);
    </script>
</body>
</html>
